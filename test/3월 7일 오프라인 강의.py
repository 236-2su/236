& 연산(and) : 둘다 1일 때 1
| 연산(or) : 하나라도 1일 때 1
^ 연산(xor) : 같으면 0 다르면 1
xor 연산을 두번쓰면 원래 숫자로 돌아온다. 암호화 가능
<<연산 : 왼쪽으로 밀어낸다.(밀어내고 생긴 빈자리에는 0이 채워짐)
>>연산 : 오른쪽으로 밀어낸다. (1비트가 지워진다.)
ex) 1<<n ==2^n
ex) ***i&(1<<n): i의 n번째 비트가 1인지 확인한다.-> 부분집합 코드에 활용가능능***

i = 1010 
n=1

음수 표현 방법
** 맨 앞자리 bit는 MSB라 하고, 1이면 음수, 0이면 양수(2의 보수)

2의 보수로 만드는 법.
    1. 수를 모두 뒤집는다.
    2. 1을 더한다.

ex) 17 -> 10001 의 2의 보수를 구해라!
    1. 수를 뒤집어라
        01110
    2. 1을 더한다.
        01111 ==  15
        
    15의 2의 보수를 하면 17이 나온다. -> 암호화 가능.

ex) -5의 2의 보수를 구해라!
    1. 5(00000101)를 뒤집는다. -> 1111 1010
    2. 1 더한다. => 1111 1011
    가장 앞에 있는 1을 MSB라고 한다.

not 연산
ex) ~4
    1. 이진수로 바꾼다(4자리씩 끊어서)
    0000 0100
    
    2. not 연산(모두 뒤집는다.)
    1|111 1011
    ㄴ> MSB 1이면 음수 0이면 양수
    
    3. 2의 보수를 취한다.
        3-1 MSB를 그대로 두고 나머지를 뒤집는다.
    1000 0100
        3-2 1을 더한다.
    1000 0101 -> -5

